"""
This type stub file was generated by pyright.
"""

import logging
from abc import ABC, abstractmethod
from collections.abc import Awaitable, Callable, Iterable
from dataclasses import dataclass
from typing import Any, Generic, TypedDict
from typing_extensions import TypeVar
from homeassistant.components import websocket_api
from homeassistant.core import HomeAssistant, callback
from homeassistant.exceptions import HomeAssistantError
from .entity import Entity
from .entity_component import EntityComponent
from .storage import Store
from .typing import ConfigType

"""Helper to deal with YAML + storage."""
STORAGE_VERSION = ...
SAVE_DELAY = ...
CHANGE_ADDED = ...
CHANGE_UPDATED = ...
CHANGE_REMOVED = ...
_ItemT = TypeVar("_ItemT")
_StoreT = TypeVar("_StoreT", bound="SerializedStorageCollection")
_StorageCollectionT = TypeVar("_StorageCollectionT", bound="StorageCollection")
_EntityT = TypeVar("_EntityT", bound=Entity, default=Entity)
@dataclass(slots=True)
class CollectionChangeSet:
    """Class to represent a change set.

    change_type: One of CHANGE_*
    item_id: The id of the item
    item: The item
    """
    change_type: str
    item_id: str
    item: Any
    ...


ChangeListener = Callable[[str, str, dict], Awaitable[None],]
ChangeSetListener = Callable[[Iterable[CollectionChangeSet]], Awaitable[None]]
class CollectionError(HomeAssistantError):
    """Base class for collection related errors."""
    ...


class ItemNotFound(CollectionError):
    """Raised when an item is not found."""
    def __init__(self, item_id: str) -> None:
        """Initialize item not found error."""
        ...
    


class IDManager:
    """Keep track of IDs across different collections."""
    def __init__(self) -> None:
        """Initiate the ID manager."""
        ...
    
    def add_collection(self, collection: dict[str, Any]) -> None:
        """Add a collection to check for ID usage."""
        ...
    
    def has_id(self, item_id: str) -> bool:
        """Test if the ID exists."""
        ...
    
    def generate_id(self, suggestion: str) -> str:
        """Generate an ID."""
        ...
    


class CollectionEntity(Entity):
    """Mixin class for entities managed by an ObservableCollection."""
    @classmethod
    @abstractmethod
    def from_storage(cls, config: ConfigType) -> CollectionEntity:
        """Create instance from storage."""
        ...
    
    @classmethod
    @abstractmethod
    def from_yaml(cls, config: ConfigType) -> CollectionEntity:
        """Create instance from yaml config."""
        ...
    
    @abstractmethod
    async def async_update_config(self, config: ConfigType) -> None:
        """Handle updated configuration."""
        ...
    


class ObservableCollection(ABC, Generic[_ItemT]):
    """Base collection type that can be observed."""
    def __init__(self, id_manager: IDManager | None) -> None:
        """Initialize the base collection."""
        ...
    
    @callback
    def async_items(self) -> list[_ItemT]:
        """Return list of items in collection."""
        ...
    
    @callback
    def async_add_listener(self, listener: ChangeListener) -> Callable[[], None]:
        """Add a listener.

        Will be called with (change_type, item_id, updated_config).
        """
        ...
    
    @callback
    def async_add_change_set_listener(self, listener: ChangeSetListener) -> Callable[[], None]:
        """Add a listener for a full change set.

        Will be called with [(change_type, item_id, updated_config), ...]
        """
        ...
    
    async def notify_changes(self, change_sets: Iterable[CollectionChangeSet]) -> None:
        """Notify listeners of a change."""
        ...
    


class YamlCollection(ObservableCollection[dict]):
    """Offer a collection based on static data."""
    def __init__(self, logger: logging.Logger, id_manager: IDManager | None = ...) -> None:
        """Initialize the storage collection."""
        ...
    
    @staticmethod
    def create_entity(entity_class: type[CollectionEntity], config: ConfigType) -> CollectionEntity:
        """Create a CollectionEntity instance."""
        ...
    
    async def async_load(self, data: list[dict]) -> None:
        """Load the YAML collection. Overrides existing data."""
        ...
    


class SerializedStorageCollection(TypedDict):
    """Serialized storage collection."""
    items: list[dict[str, Any]]
    ...


class StorageCollection(ObservableCollection[_ItemT], Generic[_ItemT, _StoreT]):
    """Offer a CRUD interface on top of JSON storage."""
    def __init__(self, store: Store[_StoreT], id_manager: IDManager | None = ...) -> None:
        """Initialize the storage collection."""
        ...
    
    @staticmethod
    def create_entity(entity_class: type[CollectionEntity], config: ConfigType) -> CollectionEntity:
        """Create a CollectionEntity instance."""
        ...
    
    @property
    def hass(self) -> HomeAssistant:
        """Home Assistant object."""
        ...
    
    async def async_load(self) -> None:
        """Load the storage Manager."""
        ...
    
    async def async_create_item(self, data: dict) -> _ItemT:
        """Create a new item."""
        ...
    
    async def async_update_item(self, item_id: str, updates: dict) -> _ItemT:
        """Update item."""
        ...
    
    async def async_delete_item(self, item_id: str) -> None:
        """Delete item."""
        ...
    


class DictStorageCollection(StorageCollection[dict, SerializedStorageCollection]):
    """A specialized StorageCollection where the items are untyped dicts."""
    ...


class IDLessCollection(YamlCollection):
    """A collection without IDs."""
    counter = ...
    async def async_load(self, data: list[dict]) -> None:
        """Load the collection. Overrides existing data."""
        ...
    


@callback
def sync_entity_lifecycle(hass: HomeAssistant, domain: str, platform: str, entity_component: EntityComponent[_EntityT], collection: StorageCollection | YamlCollection, entity_class: type[CollectionEntity]) -> None:
    """Map a collection to an entity component."""
    ...

class StorageCollectionWebsocket(Generic[_StorageCollectionT]):
    """Class to expose storage collection management over websocket."""
    def __init__(self, storage_collection: _StorageCollectionT, api_prefix: str, model_name: str, create_schema: dict, update_schema: dict) -> None:
        """Initialize a websocket CRUD."""
        ...
    
    @property
    def item_id_key(self) -> str:
        """Return item ID key."""
        ...
    
    @callback
    def async_setup(self, hass: HomeAssistant, *, create_list: bool = ..., create_create: bool = ...) -> None:
        """Set up the websocket commands."""
        ...
    
    @callback
    def ws_list_item(self, hass: HomeAssistant, connection: websocket_api.ActiveConnection, msg: dict) -> None:
        """List items."""
        ...
    
    async def ws_create_item(self, hass: HomeAssistant, connection: websocket_api.ActiveConnection, msg: dict) -> None:
        """Create a item."""
        ...
    
    async def ws_update_item(self, hass: HomeAssistant, connection: websocket_api.ActiveConnection, msg: dict) -> None:
        """Update a item."""
        ...
    
    async def ws_delete_item(self, hass: HomeAssistant, connection: websocket_api.ActiveConnection, msg: dict) -> None:
        """Delete a item."""
        ...
    


class DictStorageCollectionWebsocket(StorageCollectionWebsocket[DictStorageCollection]):
    """Class to expose storage collection management over websocket."""
    ...


