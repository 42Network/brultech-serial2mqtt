"""
This type stub file was generated by pyright.
"""

import logging
from abc import abstractmethod
from collections.abc import Awaitable, Callable, Coroutine, Generator
from datetime import datetime, timedelta
from typing import Any, Generic, Protocol, TypeVar
from homeassistant.core import CALLBACK_TYPE, HomeAssistant, callback
from . import entity
from .debounce import Debouncer

"""Helpers to help coordinate updates."""
REQUEST_REFRESH_DEFAULT_COOLDOWN = ...
REQUEST_REFRESH_DEFAULT_IMMEDIATE = ...
_DataT = TypeVar("_DataT")
_BaseDataUpdateCoordinatorT = TypeVar("_BaseDataUpdateCoordinatorT", bound="BaseDataUpdateCoordinatorProtocol")
_DataUpdateCoordinatorT = TypeVar("_DataUpdateCoordinatorT", bound="DataUpdateCoordinator[Any]")
class UpdateFailed(Exception):
    """Raised when an update has failed."""
    ...


class BaseDataUpdateCoordinatorProtocol(Protocol):
    """Base protocol type for DataUpdateCoordinator."""
    @callback
    def async_add_listener(self, update_callback: CALLBACK_TYPE, context: Any = ...) -> Callable[[], None]:
        """Listen for data updates."""
        ...
    


class DataUpdateCoordinator(BaseDataUpdateCoordinatorProtocol, Generic[_DataT]):
    """Class to manage fetching data from single endpoint.

    Setting :attr:`always_update` to ``False`` will cause coordinator to only
    callback listeners when data has changed. This requires that the data
    implements ``__eq__`` or uses a python object that already does.
    """
    def __init__(self, hass: HomeAssistant, logger: logging.Logger, *, name: str, update_interval: timedelta | None = ..., update_method: Callable[[], Awaitable[_DataT]] | None = ..., request_refresh_debouncer: Debouncer[Coroutine[Any, Any, None]] | None = ..., always_update: bool = ...) -> None:
        """Initialize global data updater."""
        ...
    
    async def async_register_shutdown(self) -> None:
        """Register shutdown on HomeAssistant stop.

        Should only be used by coordinators that are not linked to a config entry.
        """
        ...
    
    @callback
    def async_add_listener(self, update_callback: CALLBACK_TYPE, context: Any = ...) -> Callable[[], None]:
        """Listen for data updates."""
        ...
    
    @callback
    def async_update_listeners(self) -> None:
        """Update all registered listeners."""
        ...
    
    async def async_shutdown(self) -> None:
        """Cancel any scheduled call, and ignore new runs."""
        ...
    
    def async_contexts(self) -> Generator[Any, None, None]:
        """Return all registered contexts."""
        ...
    
    async def async_request_refresh(self) -> None:
        """Request a refresh.

        Refresh will wait a bit to see if it can batch them.
        """
        ...
    
    async def async_config_entry_first_refresh(self) -> None:
        """Refresh data for the first time when a config entry is setup.

        Will automatically raise ConfigEntryNotReady if the refresh
        fails. Additionally logging is handled by config entry setup
        to ensure that multiple retries do not cause log spam.
        """
        ...
    
    async def async_refresh(self) -> None:
        """Refresh data and log errors."""
        ...
    
    @callback
    def async_set_update_error(self, err: Exception) -> None:
        """Manually set an error, log the message and notify listeners."""
        ...
    
    @callback
    def async_set_updated_data(self, data: _DataT) -> None:
        """Manually update data, notify listeners and reset refresh interval."""
        ...
    


class TimestampDataUpdateCoordinator(DataUpdateCoordinator[_DataT]):
    """DataUpdateCoordinator which keeps track of the last successful update."""
    last_update_success_time: datetime | None = ...


class BaseCoordinatorEntity(entity.Entity, Generic[_BaseDataUpdateCoordinatorT]):
    """Base class for all Coordinator entities."""
    def __init__(self, coordinator: _BaseDataUpdateCoordinatorT, context: Any = ...) -> None:
        """Create the entity with a DataUpdateCoordinator."""
        ...
    
    @property
    def should_poll(self) -> bool:
        """No need to poll. Coordinator notifies entity of updates."""
        ...
    
    async def async_added_to_hass(self) -> None:
        """When entity is added to hass."""
        ...
    
    @abstractmethod
    async def async_update(self) -> None:
        """Update the entity.

        Only used by the generic entity update service.
        """
        ...
    


class CoordinatorEntity(BaseCoordinatorEntity[_DataUpdateCoordinatorT]):
    """A class for entities using DataUpdateCoordinator."""
    def __init__(self, coordinator: _DataUpdateCoordinatorT, context: Any = ...) -> None:
        """Create the entity with a DataUpdateCoordinator.

        Passthrough to BaseCoordinatorEntity.

        Necessary to bind TypeVar to correct scope.
        """
        ...
    
    @property
    def available(self) -> bool:
        """Return if entity is available."""
        ...
    
    async def async_update(self) -> None:
        """Update the entity.

        Only used by the generic entity update service.
        """
        ...
    


