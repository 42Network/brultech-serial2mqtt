"""
This type stub file was generated by pyright.
"""

import datetime
import numpy as np
from collections import deque
from collections.abc import Callable, Coroutine, Iterable
from dataclasses import dataclass
from enum import IntEnum
from typing import Any, TYPE_CHECKING
from aiohttp import web
from homeassistant.components.http.view import HomeAssistantView
from homeassistant.core import HomeAssistant, callback
from homeassistant.util.decorator import Registry
from av import CodecContext, Packet
from homeassistant.components.camera import DynamicStreamSettings
from . import Stream

"""Provides core stream functionality."""
if TYPE_CHECKING:
    ...
_LOGGER = ...
PROVIDERS: Registry[str, type[StreamOutput]] = ...
class Orientation(IntEnum):
    """Orientations for stream transforms. These are based on EXIF orientation tags."""
    NO_TRANSFORM = ...
    MIRROR = ...
    ROTATE_180 = ...
    FLIP = ...
    ROTATE_LEFT_AND_FLIP = ...
    ROTATE_LEFT = ...
    ROTATE_RIGHT_AND_FLIP = ...
    ROTATE_RIGHT = ...


@dataclass(slots=True)
class StreamSettings:
    """Stream settings."""
    ll_hls: bool
    min_segment_duration: float
    part_target_duration: float
    hls_advance_part_limit: int
    hls_part_timeout: float
    ...


STREAM_SETTINGS_NON_LL_HLS = ...
@dataclass(slots=True)
class Part:
    """Represent a segment part."""
    duration: float
    has_keyframe: bool
    data: bytes
    ...


@dataclass(slots=True)
class Segment:
    """Represent a segment."""
    sequence: int
    init: bytes
    stream_id: int
    start_time: datetime.datetime
    _stream_outputs: Iterable[StreamOutput]
    duration: float = ...
    parts: list[Part] = ...
    hls_playlist_template: list[str] = ...
    hls_playlist_parts: list[str] = ...
    hls_num_parts_rendered: int = ...
    hls_playlist_complete: bool = ...
    def __post_init__(self) -> None:
        """Run after init."""
        ...
    
    @property
    def complete(self) -> bool:
        """Return whether the Segment is complete."""
        ...
    
    @property
    def data_size_with_init(self) -> int:
        """Return the size of all part data + init in bytes."""
        ...
    
    @property
    def data_size(self) -> int:
        """Return the size of all part data without init in bytes."""
        ...
    
    @callback
    def async_add_part(self, part: Part, duration: float) -> None:
        """Add a part to the Segment.

        Duration is non zero only for the last part.
        """
        ...
    
    def get_data(self) -> bytes:
        """Return reconstructed data for all parts as bytes, without init."""
        ...
    
    def render_hls(self, last_stream_id: int, render_parts: bool, add_hint: bool) -> str:
        """Render the HLS playlist section for the Segment including a hint if requested."""
        ...
    


class IdleTimer:
    """Invoke a callback after an inactivity timeout.

    The IdleTimer invokes the callback after some timeout has passed. The awake() method
    resets the internal alarm, extending the inactivity time.
    """
    def __init__(self, hass: HomeAssistant, timeout: int, idle_callback: Callable[[], Coroutine[Any, Any, None]]) -> None:
        """Initialize IdleTimer."""
        ...
    
    def start(self) -> None:
        """Start the idle timer if not already started."""
        ...
    
    def awake(self) -> None:
        """Keep the idle time alive by resetting the timeout."""
        ...
    
    def clear(self) -> None:
        """Clear and disable the timer if it has not already fired."""
        ...
    
    @callback
    def fire(self, _now: datetime.datetime) -> None:
        """Invoke the idle timeout callback, called when the alarm fires."""
        ...
    


class StreamOutput:
    """Represents a stream output."""
    def __init__(self, hass: HomeAssistant, idle_timer: IdleTimer, stream_settings: StreamSettings, dynamic_stream_settings: DynamicStreamSettings, deque_maxlen: int | None = ...) -> None:
        """Initialize a stream output."""
        ...
    
    @property
    def name(self) -> str | None:
        """Return provider name."""
        ...
    
    @property
    def idle(self) -> bool:
        """Return True if the output is idle."""
        ...
    
    @property
    def last_sequence(self) -> int:
        """Return the last sequence number without iterating."""
        ...
    
    @property
    def sequences(self) -> list[int]:
        """Return current sequence from segments."""
        ...
    
    @property
    def last_segment(self) -> Segment | None:
        """Return the last segment without iterating."""
        ...
    
    def get_segment(self, sequence: int) -> Segment | None:
        """Retrieve a specific segment."""
        ...
    
    def get_segments(self) -> deque[Segment]:
        """Retrieve all segments."""
        ...
    
    async def part_recv(self, timeout: float | None = ...) -> bool:
        """Wait for an event signalling the latest part segment."""
        ...
    
    def part_put(self) -> None:
        """Set event signalling the latest part segment."""
        ...
    
    async def recv(self) -> bool:
        """Wait for the latest segment."""
        ...
    
    def put(self, segment: Segment) -> None:
        """Store output."""
        ...
    
    def cleanup(self) -> None:
        """Handle cleanup."""
        ...
    


class StreamView(HomeAssistantView):
    """Base StreamView.

    For implementation of a new stream format, define `url` and `name`
    attributes, and implement `handle` method in a child class.
    """
    requires_auth = ...
    async def get(self, request: web.Request, token: str, sequence: str = ..., part_num: str = ...) -> web.StreamResponse:
        """Start a GET request."""
        ...
    
    async def handle(self, request: web.Request, stream: Stream, sequence: str, part_num: str) -> web.StreamResponse:
        """Handle the stream request."""
        ...
    


TRANSFORM_IMAGE_FUNCTION = ...
class KeyFrameConverter:
    """Enables generating and getting an image from the last keyframe seen in the stream.

    An overview of the thread and state interaction:
        the worker thread sets a packet
        get_image is called from the main asyncio loop
        get_image schedules _generate_image in an executor thread
        _generate_image will try to create an image from the packet
        _generate_image will clear the packet, so there will only be one attempt per packet
    If successful, self._image will be updated and returned by get_image
    If unsuccessful, get_image will return the previous image
    """
    def __init__(self, hass: HomeAssistant, stream_settings: StreamSettings, dynamic_stream_settings: DynamicStreamSettings) -> None:
        """Initialize."""
        ...
    
    def stash_keyframe_packet(self, packet: Packet) -> None:
        """Store the keyframe and set the asyncio.Event from the event loop.

        This is called from the worker thread.
        """
        ...
    
    def create_codec_context(self, codec_context: CodecContext) -> None:
        """Create a codec context to be used for decoding the keyframes.

        This is run by the worker thread and will only be called once per worker.
        """
        ...
    
    @staticmethod
    def transform_image(image: np.ndarray, orientation: int) -> np.ndarray:
        """Transform image to a given orientation."""
        ...
    
    async def async_get_image(self, width: int | None = ..., height: int | None = ..., wait_for_next_keyframe: bool = ...) -> bytes | None:
        """Fetch an image from the Stream and return it as a jpeg in bytes."""
        ...
    


