"""
This type stub file was generated by pyright.
"""

from collections.abc import Callable, Collection, Generator, Iterable, Sequence
from contextlib import contextmanager
from datetime import date, datetime
from typing import Any, Concatenate, TYPE_CHECKING, TypeVar
from sqlalchemy.engine import Result, Row
from sqlalchemy.engine.interfaces import DBAPIConnection
from sqlalchemy.orm.query import Query
from sqlalchemy.orm.session import Session
from sqlalchemy.sql.lambdas import StatementLambdaElement
from homeassistant.core import HomeAssistant
from .models import DatabaseEngine, StatisticPeriod
from sqlite3.dbapi2 import Cursor as SQLiteCursor
from . import Recorder

"""SQLAlchemy util functions."""
if TYPE_CHECKING:
    ...
_RecorderT = TypeVar("_RecorderT", bound="Recorder")
_P = ...
_LOGGER = ...
RETRIES = ...
QUERY_RETRY_WAIT = ...
SQLITE3_POSTFIXES = ...
DEFAULT_YIELD_STATES_ROWS = ...
MIN_VERSION_MARIA_DB = ...
RECOMMENDED_MIN_VERSION_MARIA_DB = ...
MARIADB_WITH_FIXED_IN_QUERIES_105 = ...
MARIA_DB_106 = ...
MARIADB_WITH_FIXED_IN_QUERIES_106 = ...
RECOMMENDED_MIN_VERSION_MARIA_DB_106 = ...
MARIA_DB_107 = ...
RECOMMENDED_MIN_VERSION_MARIA_DB_107 = ...
MARIADB_WITH_FIXED_IN_QUERIES_107 = ...
MARIA_DB_108 = ...
RECOMMENDED_MIN_VERSION_MARIA_DB_108 = ...
MARIADB_WITH_FIXED_IN_QUERIES_108 = ...
MIN_VERSION_MYSQL = ...
MIN_VERSION_PGSQL = ...
MIN_VERSION_SQLITE = ...
MIN_VERSION_SQLITE_MODERN_BIND_VARS = ...
MAX_RESTART_TIME = ...
RETRYABLE_MYSQL_ERRORS = ...
FIRST_POSSIBLE_SUNDAY = ...
SUNDAY_WEEKDAY = ...
DAYS_IN_WEEK = ...
@contextmanager
def session_scope(*, hass: HomeAssistant | None = ..., session: Session | None = ..., exception_filter: Callable[[Exception], bool] | None = ..., read_only: bool = ...) -> Generator[Session, None, None]:
    """Provide a transactional scope around a series of operations.

    read_only is used to indicate that the session is only used for reading
    data and that no commit is required. It does not prevent the session
    from writing and is not a security measure.
    """
    ...

def execute(qry: Query, to_native: bool = ..., validate_entity_ids: bool = ...) -> list[Row]:
    """Query the database and convert the objects to HA native form.

    This method also retries a few times in the case of stale connections.
    """
    ...

def execute_stmt_lambda_element(session: Session, stmt: StatementLambdaElement, start_time: datetime | None = ..., end_time: datetime | None = ..., yield_per: int = ..., orm_rows: bool = ...) -> Sequence[Row] | Result:
    """Execute a StatementLambdaElement.

    If the time window passed is greater than one day
    the execution method will switch to yield_per to
    reduce memory pressure.

    It is not recommended to pass a time window
    when selecting non-ranged rows (ie selecting
    specific entities) since they are usually faster
    with .all().
    """
    ...

def validate_or_move_away_sqlite_database(dburl: str) -> bool:
    """Ensure that the database is valid or move it away."""
    ...

def dburl_to_path(dburl: str) -> str:
    """Convert the db url into a filesystem path."""
    ...

def last_run_was_recently_clean(cursor: SQLiteCursor) -> bool:
    """Verify the last recorder run was recently clean."""
    ...

def basic_sanity_check(cursor: SQLiteCursor) -> bool:
    """Check tables to make sure select does not fail."""
    ...

def validate_sqlite_database(dbpath: str) -> bool:
    """Run a quick check on an sqlite database to see if it is corrupt."""
    ...

def run_checks_on_open_db(dbpath: str, cursor: SQLiteCursor) -> None:
    """Run checks that will generate a sqlite3 exception if there is corruption."""
    ...

def move_away_broken_database(dbfile: str) -> None:
    """Move away a broken sqlite3 database."""
    ...

def execute_on_connection(dbapi_connection: DBAPIConnection, statement: str) -> None:
    """Execute a single statement with a dbapi connection."""
    ...

def query_on_connection(dbapi_connection: DBAPIConnection, statement: str) -> Any:
    """Execute a single statement with a dbapi connection and return the result."""
    ...

def build_mysqldb_conv() -> dict:
    """Build a MySQLDB conv dict that uses cisco8601 to parse datetimes."""
    ...

def setup_connection_for_dialect(instance: Recorder, dialect_name: str, dbapi_connection: DBAPIConnection, first_connection: bool) -> DatabaseEngine | None:
    """Execute statements needed for dialect connection."""
    ...

def end_incomplete_runs(session: Session, start_time: datetime) -> None:
    """End any incomplete recorder runs."""
    ...

_FuncType = Callable[Concatenate[_RecorderT, _P], bool]
def retryable_database_job(description: str) -> Callable[[_FuncType[_RecorderT, _P]], _FuncType[_RecorderT, _P]]:
    """Try to execute a database job.

    The job should return True if it finished, and False if it needs to be rescheduled.
    """
    ...

_WrappedFuncType = Callable[Concatenate[_RecorderT, _P], None]
def database_job_retry_wrapper(description: str, attempts: int = ...) -> Callable[[_WrappedFuncType[_RecorderT, _P]], _WrappedFuncType[_RecorderT, _P]]:
    """Try to execute a database job multiple times.

    This wrapper handles InnoDB deadlocks and lock timeouts.

    This is different from retryable_database_job in that it will retry the job
    attempts number of times instead of returning False if the job fails.
    """
    ...

def periodic_db_cleanups(instance: Recorder) -> None:
    """Run any database cleanups that need to happen periodically.

    These cleanups will happen nightly or after any purge.
    """
    ...

@contextmanager
def write_lock_db_sqlite(instance: Recorder) -> Generator[None, None, None]:
    """Lock database for writes."""
    ...

def async_migration_in_progress(hass: HomeAssistant) -> bool:
    """Determine if a migration is in progress.

    This is a thin wrapper that allows us to change
    out the implementation later.
    """
    ...

def async_migration_is_live(hass: HomeAssistant) -> bool:
    """Determine if a migration is live.

    This is a thin wrapper that allows us to change
    out the implementation later.
    """
    ...

def second_sunday(year: int, month: int) -> date:
    """Return the datetime.date for the second sunday of a month."""
    ...

def is_second_sunday(date_time: datetime) -> bool:
    """Check if a time is the second sunday of the month."""
    ...

def get_instance(hass: HomeAssistant) -> Recorder:
    """Get the recorder instance."""
    ...

PERIOD_SCHEMA = ...
def resolve_period(period_def: StatisticPeriod) -> tuple[datetime | None, datetime | None]:
    """Return start and end datetimes for a statistic period definition."""
    ...

def take(take_num: int, iterable: Iterable) -> list[Any]:
    """Return first n items of the iterable as a list.

    From itertools recipes
    """
    ...

def chunked(iterable: Iterable, chunked_num: int) -> Iterable[Any]:
    """Break *iterable* into lists of length *n*.

    From more-itertools
    """
    ...

def chunked_or_all(iterable: Collection[Any], chunked_num: int) -> Iterable[Any]:
    """Break *collection* into iterables of length *n*.

    Returns the collection if its length is less than *n*.

    Unlike chunked, this function requires a collection so it can
    determine the length of the collection and return the collection
    if it is less than *n*.
    """
    ...

def get_index_by_name(session: Session, table_name: str, index_name: str) -> str | None:
    """Get an index by name."""
    ...

