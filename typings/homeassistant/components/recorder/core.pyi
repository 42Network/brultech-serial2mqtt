"""
This type stub file was generated by pyright.
"""

import asyncio
import threading
from collections.abc import Callable, Iterable
from datetime import datetime
from typing import Any, TypeVar
from sqlalchemy.orm.session import Session
from homeassistant.core import HomeAssistant, callback
from homeassistant.helpers.typing import UndefinedType
from .const import SupportedDialect
from .db_schema import Statistics, StatisticsShortTerm
from .models import StatisticData, StatisticMetaData
from .tasks import RecorderTask

"""Support for recording details."""
_LOGGER = ...
T = TypeVar("T")
DEFAULT_URL = ...
EXPIRE_AFTER_COMMITS = ...
SHUTDOWN_TASK = ...
COMMIT_TASK = ...
KEEP_ALIVE_TASK = ...
WAIT_TASK = ...
ADJUST_LRU_SIZE_TASK = ...
DB_LOCK_TIMEOUT = ...
DB_LOCK_QUEUE_CHECK_TIMEOUT = ...
INVALIDATED_ERR = ...
CONNECTIVITY_ERR = ...
MAX_DB_EXECUTOR_WORKERS = ...
class Recorder(threading.Thread):
    """A threaded recorder class."""
    stop_requested: bool
    def __init__(self, hass: HomeAssistant, auto_purge: bool, auto_repack: bool, keep_days: int, commit_interval: int, uri: str, db_max_retries: int, db_retry_wait: int, entity_filter: Callable[[str], bool], exclude_event_types: set[str]) -> None:
        """Initialize the recorder."""
        ...
    
    @property
    def backlog(self) -> int:
        """Return the number of items in the recorder backlog."""
        ...
    
    @property
    def dialect_name(self) -> SupportedDialect | None:
        """Return the dialect the recorder uses."""
        ...
    
    @property
    def recording(self) -> bool:
        """Return if the recorder is recording."""
        ...
    
    def get_session(self) -> Session:
        """Get a new sqlalchemy session."""
        ...
    
    def queue_task(self, task: RecorderTask) -> None:
        """Add a task to the recorder queue."""
        ...
    
    def set_enable(self, enable: bool) -> None:
        """Enable or disable recording events and states."""
        ...
    
    @callback
    def async_start_executor(self) -> None:
        """Start the executor."""
        ...
    
    @callback
    def async_initialize(self) -> None:
        """Initialize the recorder."""
        ...
    
    @callback
    def async_add_executor_job(self, target: Callable[..., T], *args: Any) -> asyncio.Future[T]:
        """Add an executor job from within the event loop."""
        ...
    
    @callback
    def async_register(self) -> None:
        """Post connection initialize."""
        ...
    
    @callback
    def async_connection_success(self) -> None:
        """Connect to the database succeeded, schema version and migration need known.

        The database may not yet be ready for use in case of a non-live migration.
        """
        ...
    
    @callback
    def async_set_db_ready(self) -> None:
        """Database live and ready for use.

        Called after non-live migration steps are finished.
        """
        ...
    
    @callback
    def async_nightly_tasks(self, now: datetime) -> None:
        """Trigger the purge."""
        ...
    
    @callback
    def async_periodic_statistics(self) -> None:
        """Trigger the statistics run.

        Short term statistics run every 5 minutes
        """
        ...
    
    @callback
    def async_adjust_statistics(self, statistic_id: str, start_time: datetime, sum_adjustment: float, adjustment_unit: str) -> None:
        """Adjust statistics."""
        ...
    
    @callback
    def async_clear_statistics(self, statistic_ids: list[str]) -> None:
        """Clear statistics for a list of statistic_ids."""
        ...
    
    @callback
    def async_update_statistics_metadata(self, statistic_id: str, *, new_statistic_id: str | UndefinedType = ..., new_unit_of_measurement: str | None | UndefinedType = ...) -> None:
        """Update statistics metadata for a statistic_id."""
        ...
    
    @callback
    def async_update_states_metadata(self, entity_id: str, new_entity_id: str) -> None:
        """Update states metadata for an entity_id."""
        ...
    
    @callback
    def async_change_statistics_unit(self, statistic_id: str, *, new_unit_of_measurement: str, old_unit_of_measurement: str) -> None:
        """Change statistics unit for a statistic_id."""
        ...
    
    @callback
    def async_import_statistics(self, metadata: StatisticMetaData, stats: Iterable[StatisticData], table: type[Statistics | StatisticsShortTerm]) -> None:
        """Schedule import of statistics."""
        ...
    
    def run(self) -> None:
        """Run the recorder thread."""
        ...
    
    async def async_block_till_done(self) -> None:
        """Async version of block_till_done."""
        ...
    
    def block_till_done(self) -> None:
        """Block till all events processed.

        This is only called in tests.

        This only blocks until the queue is empty
        which does not mean the recorder is done.

        Call tests.common's wait_recording_done
        after calling this to ensure the data
        is in the database.
        """
        ...
    
    async def lock_database(self) -> bool:
        """Lock database so it can be backed up safely."""
        ...
    
    @callback
    def unlock_database(self) -> bool:
        """Unlock database.

        Returns true if database lock has been held throughout the process.
        """
        ...
    


